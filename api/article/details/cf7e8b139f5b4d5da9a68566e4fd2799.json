{
    "props": {
        "pageProps": {
            "query": {
                "id": "cf7e8b139f5b4d5da9a68566e4fd2799"
            },
            "ieBrowser": false,
            "needRefresh": false,
            "writingDetail": {
                "id": 85261,
                "outId": "cf7e8b139f5b4d5da9a68566e4fd2799",
                "articleOutId": "cf7e8b139f5b4d5da9a68566e4fd2799",
                "html": "<h1 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 24px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">用 Folium 绘制地理空间矢量场</span><span class=\"suffix\"></span></h1> \n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 17px; word-spacing: 3px; letter-spacing: 1px;\">地学和许多应用领域中，数据的视觉化非常重要。尤其是一些表示方向和速度的矢量数据，例如风速、海流、车速等，使用矢量图进行绘制能够更加直观地表达这些数据的特性。</p> \n<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"background-color: #F7D3CC; color: #FFF; padding: 5px 15px; border-radius: 1px;\">示例数据集选择</span><span class=\"suffix\"></span></h2> \n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 17px; word-spacing: 3px; letter-spacing: 1px;\">为了便于说明矢量场的绘制方法，我们选择了一个实际的例子：纽约市的 Citi Bike 数据集。Citi Bike 是纽约市一个著名的自行车共享系统，该数据集涵盖了数百万次骑行，包含每次骑行的起点和终点位置。我们将利用这些信息计算每次骑行的速度向量。</p> \n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">数据准备与处理</span><span class=\"suffix\" style=\"display: none;\"></span></h3> \n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 17px; word-spacing: 3px; letter-spacing: 1px;\">首先，我们需要导入所需的Python库并准备工作环境。以下是我们将使用的主要库：</p> \n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;\"> \n <li> \n  <section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;\"> <strong style=\"font-weight: bold; color: black;\">Folium</strong>：一个用于在Python中绘制交互式地图的库。 \n  </section></li> \n <li> \n  <section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;\"> <strong style=\"font-weight: bold; color: black;\">H3</strong>：一个地理空间索引库，支持六边形网格划分。 \n  </section></li> \n <li> \n  <section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;\"> <strong style=\"font-weight: bold; color: black;\">Pandas</strong> 和 <strong style=\"font-weight: bold; color: black;\">Numpy</strong>：用于数据处理和数值计算。 \n  </section></li> \n <li> \n  <section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;\"> <strong style=\"font-weight: bold; color: black;\">Matplotlib</strong>：用于数据可视化。 \n  </section></li> \n <li> \n  <section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;\"> <strong style=\"font-weight: bold; color: black;\">Pyproj</strong>：用于地理计算。 \n  </section></li> \n <li> \n  <section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;\"> <strong style=\"font-weight: bold; color: black;\">SciPy</strong>：用于统计计算。 \n  </section></li> \n</ul> \n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 17px; word-spacing: 3px; letter-spacing: 1px;\">我们从本地的存储目录中加载Citi Bike数据集，读取每个CSV文件并将它们合并为一个DataFrame。</p> \n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #333; background: #f8f8f8; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch;\">import&nbsp;json<br><br>import&nbsp;matplotlib.pyplot&nbsp;as&nbsp;plt<br>import&nbsp;numpy&nbsp;as&nbsp;np<br><br>import&nbsp;h3<br><br>import&nbsp;folium<br>from&nbsp;geojson&nbsp;import&nbsp;Feature,&nbsp;FeatureCollection<br><br>import&nbsp;math<br>import&nbsp;matplotlib<br><br>from&nbsp;scipy&nbsp;import&nbsp;stats<br>import&nbsp;pandas&nbsp;as&nbsp;pd<br><br>from&nbsp;pandarallel&nbsp;import&nbsp;pandarallel<br><br>import&nbsp;scipy.stats&nbsp;as&nbsp;scs<br><br><br>import&nbsp;os<br>import&nbsp;pandas&nbsp;as&nbsp;pd<br>import&nbsp;zipfile<br><br>os.chdir(<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">'/home/mw/input/tripdata5123'</span>)<br><br>zf&nbsp;=&nbsp;os.listdir(<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">'/home/mw/input/tripdata5123/202406-citibike-tripdata'</span>)<br>result_data&nbsp;=&nbsp;[]<br><span class=\"hljs-built_in\" style=\"color: #0086b3; line-height: 26px;\">print</span>(<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"Reading:\"</span>)<br><br><span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">for</span>&nbsp;zfcsv&nbsp;<span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">in</span>&nbsp;zf:<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-built_in\" style=\"color: #0086b3; line-height: 26px;\">print</span>(zfcsv)<br>&nbsp;&nbsp;&nbsp;&nbsp;df&nbsp;=&nbsp;pd.read_csv(<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">'/home/mw/input/tripdata5123/202406-citibike-tripdata/'</span>&nbsp;+&nbsp;zfcsv,&nbsp;low_memory=False)<br>&nbsp;&nbsp;&nbsp;&nbsp;result_data.append(df)<br><br>df&nbsp;=&nbsp;pd.concat(result_data)<br><span class=\"hljs-built_in\" style=\"color: #0086b3; line-height: 26px;\">print</span>(<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"Done!\"</span>)<br>result_data&nbsp;=&nbsp;None<br></code></pre> \n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">数据清理</span><span class=\"suffix\" style=\"display: none;\"></span></h3> \n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 17px; word-spacing: 3px; letter-spacing: 1px;\">在进行分析之前，通常需要对数据进行清理。我们首先去掉所有缺失值（NaN）以确保后续计算的准确性。</p> \n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #333; background: #f8f8f8; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch;\">df&nbsp;=&nbsp;df.dropna()<br><span class=\"hljs-built_in\" style=\"color: #0086b3; line-height: 26px;\">print</span>(len(df))<br><span class=\"hljs-comment\" style=\"color: #998; font-style: italic; line-height: 26px;\">#df&nbsp;=&nbsp;df.sample(10000)</span><br></code></pre> \n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">计算骑行中点和近似航向</span><span class=\"suffix\" style=\"display: none;\"></span></h3> \n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 17px; word-spacing: 3px; letter-spacing: 1px;\">为了将每次骑行归纳到一个中心点，我们计算了起点和终点的中点。同时，为了简化计算，我们使用近似值来估算航向（从起点到终点的方向角度）。需要注意的是，这种近似方式并不完全精确。</p> \n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #333; background: #f8f8f8; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch;\"><span class=\"hljs-comment\" style=\"color: #998; font-style: italic; line-height: 26px;\">#&nbsp;we&nbsp;choose&nbsp;the&nbsp;middle&nbsp;position&nbsp;instead&nbsp;of&nbsp;the&nbsp;start&nbsp;or&nbsp;end&nbsp;position&nbsp;to&nbsp;plot</span><br>df[<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">'latitude'</span>]&nbsp;=&nbsp;(df[<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">'start_lat'</span>]&nbsp;+&nbsp;df[<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">'end_lat'</span>])/2.0<br>df[<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">'longitude'</span>]&nbsp;=&nbsp;(df[<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">'start_lng'</span>]&nbsp;+&nbsp;df[<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">'end_lng'</span>])/2.0<br><br><span class=\"hljs-comment\" style=\"color: #998; font-style: italic; line-height: 26px;\">#&nbsp;we&nbsp;approximate&nbsp;bearing&nbsp;like&nbsp;this&nbsp;--&nbsp;no,&nbsp;it&nbsp;is&nbsp;not&nbsp;entirely&nbsp;correct!</span><br>df[<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">'bearing_approx'</span>]&nbsp;=&nbsp;90.0&nbsp;-&nbsp;360&nbsp;*&nbsp;(np.arctan2(df[<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">'end_lat'</span>]&nbsp;-&nbsp;df[<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">'start_lat'</span>],&nbsp;df[<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">'end_lng'</span>]&nbsp;-&nbsp;df[<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">'start_lng'</span>])&nbsp;/&nbsp;(2*math.pi))<br><br>df[<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">'timestamp'</span>]&nbsp;=&nbsp;pd.to_datetime(df[<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">'ended_at'</span>])<br>df[<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">'duration'</span>]&nbsp;=&nbsp;df[<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">'timestamp'</span>]&nbsp;-&nbsp;pd.to_datetime(df[<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">'started_at'</span>])<br>df[<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">'hour_of_day'</span>]&nbsp;=&nbsp;df[<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">'timestamp'</span>].dt.hour<br><br></code></pre> \n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">计算距离和速度</span><span class=\"suffix\" style=\"display: none;\"></span></h3> \n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 17px; word-spacing: 3px; letter-spacing: 1px;\">接下来，我们使用H3库来计算每次骑行的直线距离，并利用计算出的距离和骑行时间来计算速度（km/h）。</p> \n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #333; background: #f8f8f8; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch;\">pandarallel.initialize(progress_bar=True)<br><br>distances&nbsp;=&nbsp;df.parallel_apply(lambda&nbsp;row:&nbsp;h3.point_dist((row.start_lat,&nbsp;row.start_lng),&nbsp;(row.end_lat,&nbsp;row.end_lng),&nbsp;unit=<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">'m'</span>),&nbsp;axis&nbsp;=&nbsp;1)<br><br>df&nbsp;=&nbsp;df.assign(distance_in_meters=distances.values)<br>distances&nbsp;=&nbsp;None<br></code></pre> \n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #333; background: #f8f8f8; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch;\">speeds&nbsp;=&nbsp;df.parallel_apply(lambda&nbsp;row:&nbsp;3.6&nbsp;*&nbsp;row.distance_in_meters&nbsp;/&nbsp;row.duration.total_seconds(),&nbsp;axis&nbsp;=&nbsp;1)<br><br>df&nbsp;=&nbsp;df.assign(speed_kmh=speeds.values)<br>speeds&nbsp;=&nbsp;None<br></code></pre> \n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">计算精确航向</span><span class=\"suffix\" style=\"display: none;\"></span></h3> \n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 17px; word-spacing: 3px; letter-spacing: 1px;\">为了得到更加精确的航向，我们使用了 <code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; color: #1e6bb8; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all;\">pyproj</code> 库中的 <code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; color: #1e6bb8; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all;\">Geod</code> 对象。这可以提供更精确的方位角计算。</p> \n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #333; background: #f8f8f8; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch;\">import&nbsp;pyproj<br><br>geodesic&nbsp;=&nbsp;pyproj.Geod(ellps=<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">'WGS84'</span>)<br><br>def&nbsp;bearing_from_lat_long_pair(start_lat,&nbsp;start_long,&nbsp;end_lat,&nbsp;end_long):<br>&nbsp;&nbsp;&nbsp;&nbsp;bearing_angle,&nbsp;_,&nbsp;_&nbsp;=&nbsp;geodesic.inv(start_long,&nbsp;start_lat,&nbsp;end_long,&nbsp;end_lat)<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">if</span>&nbsp;bearing_angle&nbsp;&lt;&nbsp;0:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bearing_angle&nbsp;=&nbsp;bearing_angle&nbsp;+&nbsp;360.0<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">if</span>&nbsp;bearing_angle&nbsp;&gt;&nbsp;360.0:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bearing_angle&nbsp;=&nbsp;bearing_angle&nbsp;-&nbsp;360.0<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-built_in\" style=\"color: #0086b3; line-height: 26px;\">return</span>&nbsp;bearing_angle<br><br>bearings_properly&nbsp;=&nbsp;df.parallel_apply(lambda&nbsp;row:&nbsp;bearing_from_lat_long_pair(row.start_lat,&nbsp;row.start_lng,&nbsp;row.end_lat,&nbsp;row.end_lng),&nbsp;axis&nbsp;=&nbsp;1)<br><br>df&nbsp;=&nbsp;df.assign(bearing=bearings_properly.values)<br><br>bearings_properly&nbsp;=&nbsp;None<br></code></pre> \n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">计算方向向量的x和y分量</span><span class=\"suffix\" style=\"display: none;\"></span></h3> \n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 17px; word-spacing: 3px; letter-spacing: 1px;\">为了更好地处理方向平均值，我们将每个方向的角度转换为x和y分量。这样，我们可以使用标准的聚合函数来计算方向的平均值。</p> \n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #333; background: #f8f8f8; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch;\">df[<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"direction_x\"</span>]&nbsp;=&nbsp;np.sin(2&nbsp;*&nbsp;math.pi&nbsp;*&nbsp;df[<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"bearing\"</span>]&nbsp;/&nbsp;360.0)<br>df[<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"direction_y\"</span>]&nbsp;=&nbsp;np.cos(2&nbsp;*&nbsp;math.pi&nbsp;*&nbsp;df[<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"bearing\"</span>]&nbsp;/&nbsp;360.0)<br></code></pre> \n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">将数据聚合到六边形网格中</span><span class=\"suffix\" style=\"display: none;\"></span></h3> \n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 17px; word-spacing: 3px; letter-spacing: 1px;\">现在，我们将数据聚合到六边形网格中。在本文的例子中，我们使用H3库将数据转换为分辨率为9的六边形网格单元。</p> \n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #333; background: #f8f8f8; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch;\">df.groupby(<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"rideable_type\"</span>,&nbsp;as_index=False).agg({<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"ride_id\"</span>:&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"count\"</span>,&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"speed_kmh\"</span>:&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"mean\"</span>&nbsp;})<br><span class=\"hljs-comment\" style=\"color: #998; font-style: italic; line-height: 26px;\">#&nbsp;CONSTANTS</span><br><br>H3_RESOLUTION&nbsp;=&nbsp;9<br><br>pandarallel.initialize(progress_bar=True)<br><br>hex_ids&nbsp;=&nbsp;df.parallel_apply(lambda&nbsp;row:&nbsp;h3.geo_to_h3(row.latitude,&nbsp;row.longitude,&nbsp;H3_RESOLUTION),&nbsp;axis&nbsp;=&nbsp;1)<br><br>df&nbsp;=&nbsp;df.assign(hex_id=hex_ids.values)<br>hex_ids&nbsp;=&nbsp;None<br></code></pre> \n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 17px; word-spacing: 3px; letter-spacing: 1px;\">现在我们有了数百万个速度矢量，我们需要将它们聚合到网格单元中， 本文的例子中是六边形。这里有个细节值得一提。取<strong style=\"font-weight: bold; color: black;\">速度</strong>的平均值（或中位数，或其他值）很简单，你可以简单地用*“speed”: “mean”执行**groupby('hexid', …) **。取方位的平均值不能以同样的方式进行，因为方位具有360 度的圆形范围（弧度，则是 2π）。</p> \n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 17px; word-spacing: 3px; letter-spacing: 1px;\">例如，2 度（几乎向北；略微向东）和 356 度（几乎向北；略微向西）的平均值肯定不是<strong style=\"font-weight: bold; color: black;\">179</strong>度（几乎向南！）。相反，在方向的世界中，合理的平均值是 359 度，它是一个 2 度角和一个 356 度角的圆平均值。</p> \n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #333; background: #f8f8f8; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch;\">import&nbsp;numpy&nbsp;as&nbsp;np<br>import&nbsp;scipy.stats<br><br><span class=\"hljs-comment\" style=\"color: #998; font-style: italic; line-height: 26px;\">#&nbsp;compass&nbsp;bearings&nbsp;in&nbsp;degrees:</span><br>data&nbsp;=&nbsp;[2,&nbsp;356]<br><br><span class=\"hljs-comment\" style=\"color: #998; font-style: italic; line-height: 26px;\">#&nbsp;average&nbsp;bearing:</span><br><span class=\"hljs-built_in\" style=\"color: #0086b3; line-height: 26px;\">print</span>(np.mean(data))&nbsp;<span class=\"hljs-comment\" style=\"color: #998; font-style: italic; line-height: 26px;\">#&nbsp;==&nbsp;179.0,&nbsp;aka&nbsp;\"wrong\"</span><br><span class=\"hljs-built_in\" style=\"color: #0086b3; line-height: 26px;\">print</span>(scipy.stats.circmean(data,&nbsp;high=360,&nbsp;low=0))&nbsp;<span class=\"hljs-comment\" style=\"color: #998; font-style: italic; line-height: 26px;\">#&nbsp;==&nbsp;359.0,&nbsp;aka&nbsp;\"correct\"</span><br><br><span class=\"hljs-built_in\" style=\"color: #0086b3; line-height: 26px;\">print</span>(np.rad2deg(np.angle(np.mean(np.cos(np.deg2rad(data))&nbsp;+&nbsp;np.sin(np.deg2rad(data))&nbsp;*&nbsp;1j))%(2*math.pi)))<br><span class=\"hljs-comment\" style=\"color: #998; font-style: italic; line-height: 26px;\">#&nbsp;==&nbsp;359.0,&nbsp;aka&nbsp;also&nbsp;correct,&nbsp;but&nbsp;achieving&nbsp;the&nbsp;result&nbsp;in&nbsp;an&nbsp;overly&nbsp;complex&nbsp;way</span><br></code></pre> \n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 17px; word-spacing: 3px; letter-spacing: 1px;\">当然，有现成的函数可以计算圆周均值 -例如<a href=\"https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.circmean.html\" style=\"text-decoration: none; color: #1e6bb8; word-wrap: break-word; font-weight: bold; border-bottom: 1px solid #1e6bb8;\"><em style=\"font-style: italic; color: black;\">scipy.stats.circmean</em></a> - 但不知道如何将它与<em style=\"font-style: italic; color: black;\">groupby</em>一起使用，所以我采用了同样简单但不太优雅的方法，即独立平均速度矢量的 x 和 y 分量，并将<em style=\"font-style: italic; color: black;\">arctan2</em>函数应用于结果。</p> \n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 17px; word-spacing: 3px; letter-spacing: 1px;\">计算六边形网格单元的平均方向和速度</p> \n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 17px; word-spacing: 3px; letter-spacing: 1px;\">计算平均速度相对简单，可以直接使用 <code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; color: #1e6bb8; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all;\">groupby</code> 聚合函数。然而，对于方向的平均值，我们需要使用向量平均的方法。通过将方向角转换为x和y分量，然后计算这些分量的平均值，我们可以得出每个六边形单元的平均方向。</p> \n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #333; background: #f8f8f8; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch;\">positions_df_byhex&nbsp;=&nbsp;df_subset.groupby(<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"hex_id\"</span>,&nbsp;as_index=False).agg({<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"longitude\"</span>:&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"mean\"</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"latitude\"</span>:&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"mean\"</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"direction_x\"</span>:&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"mean\"</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"direction_y\"</span>:&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"mean\"</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"bearing\"</span>:&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"count\"</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"speed_kmh\"</span>:&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"mean\"</span><br>&nbsp;&nbsp;})<br></code></pre> \n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 17px; word-spacing: 3px; letter-spacing: 1px;\">另一个容易犯的错误是混淆方位（通常以北为零，顺时针测量）和数学角度（以正 x 轴为零，逆时针测量）。还有一点：如果您的矢量指的是<em style=\"font-style: italic; color: black;\">风</em>，风向通常是指风吹<em style=\"font-style: italic; color: black;\">来的</em>方向，而不是空气流动的方向。</p> \n<blockquote class=\"multiquote-1\" data-tool=\"mdnice编辑器\" style=\"border: none; display: block; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; border-left: 3px solid rgba(0, 0, 0, 0.4); background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px;\"> \n <p style=\"padding-top: 8px; padding-bottom: 8px; font-size: 17px; word-spacing: 3px; letter-spacing: 1px; margin: 0px; color: black; line-height: 26px;\">将这些错误加在一起，很容易就会得到本来应该是逆时针的方向，但却是顺时针方向，<strong style=\"font-weight: bold; color: black;\">和/或</strong>偏移 +90、-90 或 +180 度，<strong style=\"font-weight: bold; color: black;\">而且</strong>从一开始就是错误聚合的。甚至没有提到弧度与度数。因此，要小心！</p> \n</blockquote> \n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 17px; word-spacing: 3px; letter-spacing: 1px;\">将自行车行程速度向量聚合到六边形单元格中，就能绘制它们了。使用六边形热图是不够的，因为对于每个单元格，除了<strong style=\"font-weight: bold; color: black;\">幅度（速度）之外，我们还有一个向量方向</strong>（方位）。因此，我们在代码中手动设计了一个小箭头符号，并用这些箭头替换六边形，颜色可以反映速度。</p> \n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #333; background: #f8f8f8; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch;\">arrow_tip_x&nbsp;=&nbsp;size_of_arrow_x&nbsp;*&nbsp;math.cos(bearing_rad)&nbsp;+&nbsp;center_lat<br>arrow_tip_y&nbsp;=&nbsp;size_of_arrow_y&nbsp;*&nbsp;math.sin(bearing_rad)&nbsp;+&nbsp;center_long<br><br>arrow_back_left_x&nbsp;=&nbsp;size_of_arrow_x&nbsp;*&nbsp;math.cos(bearing_rad&nbsp;+&nbsp;2*math.pi&nbsp;*&nbsp;135.0&nbsp;/&nbsp;360.0&nbsp;)&nbsp;+&nbsp;center_lat<br>arrow_back_left_y&nbsp;=&nbsp;size_of_arrow_y&nbsp;*&nbsp;math.sin(bearing_rad&nbsp;+&nbsp;2*math.pi&nbsp;*&nbsp;135.0&nbsp;/&nbsp;360.0&nbsp;)&nbsp;+&nbsp;center_long<br><br>arrow_back_x&nbsp;=&nbsp;size_of_arrow_x&nbsp;*&nbsp;0.2&nbsp;*&nbsp;math.cos(bearing_rad&nbsp;+&nbsp;2*math.pi&nbsp;*&nbsp;180.0&nbsp;/&nbsp;360.0&nbsp;)&nbsp;+&nbsp;center_lat<br>arrow_back_y&nbsp;=&nbsp;size_of_arrow_y&nbsp;*&nbsp;0.2&nbsp;*&nbsp;math.sin(bearing_rad&nbsp;+&nbsp;2*math.pi&nbsp;*&nbsp;180.0&nbsp;/&nbsp;360.0&nbsp;)&nbsp;+&nbsp;center_long<br><br>arrow_back_right_x&nbsp;=&nbsp;size_of_arrow_x&nbsp;*&nbsp;math.cos(bearing_rad&nbsp;+&nbsp;2*math.pi&nbsp;*&nbsp;225.0&nbsp;/&nbsp;360.0&nbsp;)&nbsp;+&nbsp;center_lat<br>arrow_back_right_y&nbsp;=&nbsp;size_of_arrow_y&nbsp;*&nbsp;math.sin(bearing_rad&nbsp;+&nbsp;2*math.pi&nbsp;*&nbsp;225.0&nbsp;/&nbsp;360.0&nbsp;)&nbsp;+&nbsp;center_long<br><br>coordinates&nbsp;=&nbsp;(&nbsp;(arrow_tip_x,&nbsp;arrow_tip_y),&nbsp;(arrow_back_left_x,&nbsp;arrow_back_left_y),&nbsp;(arrow_back_x,&nbsp;arrow_back_y),&nbsp;(arrow_back_right_x,&nbsp;arrow_back_right_y),&nbsp;(arrow_tip_x,&nbsp;arrow_tip_y)&nbsp;)<br><br>geometry_for_row&nbsp;=&nbsp;{&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"type\"</span>&nbsp;:&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"Polygon\"</span>,&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"coordinates\"</span>:&nbsp;[&nbsp;coordinates&nbsp;]&nbsp;}<br></code></pre> \n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 17px; word-spacing: 3px; letter-spacing: 1px;\">我们选择速度百分位数来利用全色彩范围，但对于某些应用程序，您可能希望使用原始值。</p> \n<figure data-tool=\"mdnice编辑器\" style=\"margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;\"> \n <img src=\"https://files.mdnice.com/user/40204/a63cd37e-8459-4c5d-bd57-4a3b6dccd384.jpg\" alt=\"image-20240831212111326\" style=\"display: block; margin: 0 auto; max-width: 100%; border-radius: 10px; border: 3px solid #F7D3CC;\"> \n <figcaption style=\"margin-top: 5px; text-align: center; color: #888; font-size: 14px;\">\n   image-20240831212111326 \n </figcaption> \n</figure> \n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">可视化矢量场</span><span class=\"suffix\" style=\"display: none;\"></span></h3> \n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 17px; word-spacing: 3px; letter-spacing: 1px;\">为了将这些聚合后的矢量可视化，我们需要将每个六边形网格单元中的速度和方向绘制成箭头。我们使用Folium库进行地图绘制，并在地图上绘制每个六边形单元的箭头。</p> \n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 17px; word-spacing: 3px; letter-spacing: 1px;\">绘制的结果很好，并可在地图上缩放。</p> \n<figure data-tool=\"mdnice编辑器\" style=\"margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;\"> \n <img src=\"https://files.mdnice.com/user/40204/b76daccd-402e-4de1-ac8b-6b8eb2c0c16c.png\" alt=\"image-20240831212137561\" style=\"display: block; margin: 0 auto; max-width: 100%; border-radius: 10px; border: 3px solid #F7D3CC;\"> \n <figcaption style=\"margin-top: 5px; text-align: center; color: #888; font-size: 14px;\">\n   image-20240831212137561 \n </figcaption> \n</figure> \n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">小结</span><span class=\"suffix\" style=\"display: none;\"></span></h3> \n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 17px; word-spacing: 3px; letter-spacing: 1px;\">通过本文的步骤，您可以学习如何从地理空间数据中提取矢量信息，并将其聚合到网格单元中进行可视化。关键点包括如何处理方向角度的聚合、如何计算速度和方向矢量，以及如何使用Folium绘制可视化地图。这种方法可以应用于许多领域，例如交通分析、气象数据分析、环境监测等。</p>",
                "title": "绘制地理空间矢量场",
                "categoryId": 3,
                "categoryName": "人工智能",
                "tagId": 116,
                "tagName": "机器学习",
                "userId": 40204,
                "userOutId": "706880289656",
                "username": "LonghaoWang",
                "avatar": "https://files.mdnice.com/pic/20a54d83-6259-4b66-8689-c8ce6b9e8616.jpg",
                "description": "用Folium绘制地理空间矢量场地学和许多应用领域中，数据的视觉化非常重要。尤其是一些表示方向和速度的矢量数据，例如风速、海流、车速等，使用矢量图进行绘制能够更加直观地表达这些数据的特性。示例数据集选",
                "level": 2,
                "publishTime": "2024/10/18",
                "readingNum": 1,
                "likeNum": 0,
                "introduction": null,
                "followWords": null,
                "followPic": null,
                "isFollowing": false,
                "isLike": false,
                "isSelf": false,
                "type": 1,
                "isVisible": true,
                "invisibleReason": null,
                "writingColumn": {
                    "columnOutId": "ffe00cb8fcef4def81f23ac36ce58752",
                    "name": "默认专栏",
                    "briefIntro": "这是一个默认专栏",
                    "cover": "https://files.mdnice.com/common/community/default-column-cover.jpg",
                    "writingNum": 54,
                    "createTime": "2024-08-06 19:05"
                }
            }
        },
        "__N_SSP": true
    },
    "page": "/writing/[id]",
    "query": {
        "id": "cf7e8b139f5b4d5da9a68566e4fd2799"
    },
    "buildId": "ErZPkD4oq6iwH2nj6Dpcx",
    "isFallback": false,
    "gssp": true,
    "appGip": true
}